"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.anyTypeAnnotation = anyTypeAnnotation;
exports.argumentPlaceholder = argumentPlaceholder;
exports.arrayExpression = arrayExpression;
exports.arrayPattern = arrayPattern;
exports.arrayTypeAnnotation = arrayTypeAnnotation;
exports.arrowFunctionExpression = arrowFunctionExpression;
exports.assignmentExpression = assignmentExpression;
exports.assignmentPattern = assignmentPattern;
exports.awaitExpression = awaitExpression;
exports.bigIntLiteral = bigIntLiteral;
exports.binaryExpression = binaryExpression;
exports.bindExpression = bindExpression;
exports.blockStatement = blockStatement;
exports.booleanLiteral = booleanLiteral;
exports.booleanLiteralTypeAnnotation = booleanLiteralTypeAnnotation;
exports.booleanTypeAnnotation = booleanTypeAnnotation;
exports.breakStatement = breakStatement;
exports.callExpression = callExpression;
exports.catchClause = catchClause;
exports.classAccessorProperty = classAccessorProperty;
exports.classBody = classBody;
exports.classDeclaration = classDeclaration;
exports.classExpression = classExpression;
exports.classImplements = classImplements;
exports.classMethod = classMethod;
exports.classPrivateMethod = classPrivateMethod;
exports.classPrivateProperty = classPrivateProperty;
exports.classProperty = classProperty;
exports.conditionalExpression = conditionalExpression;
exports.continueStatement = continueStatement;
exports.debuggerStatement = debuggerStatement;
exports.decimalLiteral = decimalLiteral;
exports.declareClass = declareClass;
exports.declareExportAllDeclaration = declareExportAllDeclaration;
exports.declareExportDeclaration = declareExportDeclaration;
exports.declareFunction = declareFunction;
exports.declareInterface = declareInterface;
exports.declareModule = declareModule;
exports.declareModuleExports = declareModuleExports;
exports.declareOpaqueType = declareOpaqueType;
exports.declareTypeAlias = declareTypeAlias;
exports.declareVariable = declareVariable;
exports.declaredPredicate = declaredPredicate;
exports.decorator = decorator;
exports.directive = directive;
exports.directiveLiteral = directiveLiteral;
exports.doExpression = doExpression;
exports.doWhileStatement = doWhileStatement;
exports.emptyStatement = emptyStatement;
exports.emptyTypeAnnotation = emptyTypeAnnotation;
exports.enumBooleanBody = enumBooleanBody;
exports.enumBooleanMember = enumBooleanMember;
exports.enumDeclaration = enumDeclaration;
exports.enumDefaultedMember = enumDefaultedMember;
exports.enumNumberBody = enumNumberBody;
exports.enumNumberMember = enumNumberMember;
exports.enumStringBody = enumStringBody;
exports.enumStringMember = enumStringMember;
exports.enumSymbolBody = enumSymbolBody;
exports.existsTypeAnnotation = existsTypeAnnotation;
exports.exportAllDeclaration = exportAllDeclaration;
exports.exportDefaultDeclaration = exportDefaultDeclaration;
exports.exportDefaultSpecifier = exportDefaultSpecifier;
exports.exportNamedDeclaration = exportNamedDeclaration;
exports.exportNamespaceSpecifier = exportNamespaceSpecifier;
exports.exportSpecifier = exportSpecifier;
exports.expressionStatement = expressionStatement;
exports.file = file;
exports.forInStatement = forInStatement;
exports.forOfStatement = forOfStatement;
exports.forStatement = forStatement;
exports.functionDeclaration = functionDeclaration;
exports.functionExpression = functionExpression;
exports.functionTypeAnnotation = functionTypeAnnotation;
exports.functionTypeParam = functionTypeParam;
exports.genericTypeAnnotation = genericTypeAnnotation;
exports.identifier = identifier;
exports.ifStatement = ifStatement;
exports["import"] = _import;
exports.importAttribute = importAttribute;
exports.importDeclaration = importDeclaration;
exports.importDefaultSpecifier = importDefaultSpecifier;
exports.importExpression = importExpression;
exports.importNamespaceSpecifier = importNamespaceSpecifier;
exports.importSpecifier = importSpecifier;
exports.indexedAccessType = indexedAccessType;
exports.inferredPredicate = inferredPredicate;
exports.interfaceDeclaration = interfaceDeclaration;
exports.interfaceExtends = interfaceExtends;
exports.interfaceTypeAnnotation = interfaceTypeAnnotation;
exports.interpreterDirective = interpreterDirective;
exports.intersectionTypeAnnotation = intersectionTypeAnnotation;
exports.jSXAttribute = exports.jsxAttribute = jsxAttribute;
exports.jSXClosingElement = exports.jsxClosingElement = jsxClosingElement;
exports.jSXClosingFragment = exports.jsxClosingFragment = jsxClosingFragment;
exports.jSXElement = exports.jsxElement = jsxElement;
exports.jSXEmptyExpression = exports.jsxEmptyExpression = jsxEmptyExpression;
exports.jSXExpressionContainer = exports.jsxExpressionContainer = jsxExpressionContainer;
exports.jSXFragment = exports.jsxFragment = jsxFragment;
exports.jSXIdentifier = exports.jsxIdentifier = jsxIdentifier;
exports.jSXMemberExpression = exports.jsxMemberExpression = jsxMemberExpression;
exports.jSXNamespacedName = exports.jsxNamespacedName = jsxNamespacedName;
exports.jSXOpeningElement = exports.jsxOpeningElement = jsxOpeningElement;
exports.jSXOpeningFragment = exports.jsxOpeningFragment = jsxOpeningFragment;
exports.jSXSpreadAttribute = exports.jsxSpreadAttribute = jsxSpreadAttribute;
exports.jSXSpreadChild = exports.jsxSpreadChild = jsxSpreadChild;
exports.jSXText = exports.jsxText = jsxText;
exports.labeledStatement = labeledStatement;
exports.logicalExpression = logicalExpression;
exports.memberExpression = memberExpression;
exports.metaProperty = metaProperty;
exports.mixedTypeAnnotation = mixedTypeAnnotation;
exports.moduleExpression = moduleExpression;
exports.newExpression = newExpression;
exports.noop = noop;
exports.nullLiteral = nullLiteral;
exports.nullLiteralTypeAnnotation = nullLiteralTypeAnnotation;
exports.nullableTypeAnnotation = nullableTypeAnnotation;
exports.numberLiteral = NumberLiteral;
exports.numberLiteralTypeAnnotation = numberLiteralTypeAnnotation;
exports.numberTypeAnnotation = numberTypeAnnotation;
exports.numericLiteral = numericLiteral;
exports.objectExpression = objectExpression;
exports.objectMethod = objectMethod;
exports.objectPattern = objectPattern;
exports.objectProperty = objectProperty;
exports.objectTypeAnnotation = objectTypeAnnotation;
exports.objectTypeCallProperty = objectTypeCallProperty;
exports.objectTypeIndexer = objectTypeIndexer;
exports.objectTypeInternalSlot = objectTypeInternalSlot;
exports.objectTypeProperty = objectTypeProperty;
exports.objectTypeSpreadProperty = objectTypeSpreadProperty;
exports.opaqueType = opaqueType;
exports.optionalCallExpression = optionalCallExpression;
exports.optionalIndexedAccessType = optionalIndexedAccessType;
exports.optionalMemberExpression = optionalMemberExpression;
exports.parenthesizedExpression = parenthesizedExpression;
exports.pipelineBareFunction = pipelineBareFunction;
exports.pipelinePrimaryTopicReference = pipelinePrimaryTopicReference;
exports.pipelineTopicExpression = pipelineTopicExpression;
exports.placeholder = placeholder;
exports.privateName = privateName;
exports.program = program;
exports.qualifiedTypeIdentifier = qualifiedTypeIdentifier;
exports.recordExpression = recordExpression;
exports.regExpLiteral = regExpLiteral;
exports.regexLiteral = RegexLiteral;
exports.restElement = restElement;
exports.restProperty = RestProperty;
exports.returnStatement = returnStatement;
exports.sequenceExpression = sequenceExpression;
exports.spreadElement = spreadElement;
exports.spreadProperty = SpreadProperty;
exports.staticBlock = staticBlock;
exports.stringLiteral = stringLiteral;
exports.stringLiteralTypeAnnotation = stringLiteralTypeAnnotation;
exports.stringTypeAnnotation = stringTypeAnnotation;
exports["super"] = _super;
exports.switchCase = switchCase;
exports.switchStatement = switchStatement;
exports.symbolTypeAnnotation = symbolTypeAnnotation;
exports.taggedTemplateExpression = taggedTemplateExpression;
exports.templateElement = templateElement;
exports.templateLiteral = templateLiteral;
exports.thisExpression = thisExpression;
exports.thisTypeAnnotation = thisTypeAnnotation;
exports.throwStatement = throwStatement;
exports.topicReference = topicReference;
exports.tryStatement = tryStatement;
exports.tSAnyKeyword = exports.tsAnyKeyword = tsAnyKeyword;
exports.tSArrayType = exports.tsArrayType = tsArrayType;
exports.tSAsExpression = exports.tsAsExpression = tsAsExpression;
exports.tSBigIntKeyword = exports.tsBigIntKeyword = tsBigIntKeyword;
exports.tSBooleanKeyword = exports.tsBooleanKeyword = tsBooleanKeyword;
exports.tSCallSignatureDeclaration = exports.tsCallSignatureDeclaration = tsCallSignatureDeclaration;
exports.tSConditionalType = exports.tsConditionalType = tsConditionalType;
exports.tSConstructSignatureDeclaration = exports.tsConstructSignatureDeclaration = tsConstructSignatureDeclaration;
exports.tSConstructorType = exports.tsConstructorType = tsConstructorType;
exports.tSDeclareFunction = exports.tsDeclareFunction = tsDeclareFunction;
exports.tSDeclareMethod = exports.tsDeclareMethod = tsDeclareMethod;
exports.tSEnumDeclaration = exports.tsEnumDeclaration = tsEnumDeclaration;
exports.tSEnumMember = exports.tsEnumMember = tsEnumMember;
exports.tSExportAssignment = exports.tsExportAssignment = tsExportAssignment;
exports.tSExpressionWithTypeArguments = exports.tsExpressionWithTypeArguments = tsExpressionWithTypeArguments;
exports.tSExternalModuleReference = exports.tsExternalModuleReference = tsExternalModuleReference;
exports.tSFunctionType = exports.tsFunctionType = tsFunctionType;
exports.tSImportEqualsDeclaration = exports.tsImportEqualsDeclaration = tsImportEqualsDeclaration;
exports.tSImportType = exports.tsImportType = tsImportType;
exports.tSIndexSignature = exports.tsIndexSignature = tsIndexSignature;
exports.tSIndexedAccessType = exports.tsIndexedAccessType = tsIndexedAccessType;
exports.tSInferType = exports.tsInferType = tsInferType;
exports.tSInstantiationExpression = exports.tsInstantiationExpression = tsInstantiationExpression;
exports.tSInterfaceBody = exports.tsInterfaceBody = tsInterfaceBody;
exports.tSInterfaceDeclaration = exports.tsInterfaceDeclaration = tsInterfaceDeclaration;
exports.tSIntersectionType = exports.tsIntersectionType = tsIntersectionType;
exports.tSIntrinsicKeyword = exports.tsIntrinsicKeyword = tsIntrinsicKeyword;
exports.tSLiteralType = exports.tsLiteralType = tsLiteralType;
exports.tSMappedType = exports.tsMappedType = tsMappedType;
exports.tSMethodSignature = exports.tsMethodSignature = tsMethodSignature;
exports.tSModuleBlock = exports.tsModuleBlock = tsModuleBlock;
exports.tSModuleDeclaration = exports.tsModuleDeclaration = tsModuleDeclaration;
exports.tSNamedTupleMember = exports.tsNamedTupleMember = tsNamedTupleMember;
exports.tSNamespaceExportDeclaration = exports.tsNamespaceExportDeclaration = tsNamespaceExportDeclaration;
exports.tSNeverKeyword = exports.tsNeverKeyword = tsNeverKeyword;
exports.tSNonNullExpression = exports.tsNonNullExpression = tsNonNullExpression;
exports.tSNullKeyword = exports.tsNullKeyword = tsNullKeyword;
exports.tSNumberKeyword = exports.tsNumberKeyword = tsNumberKeyword;
exports.tSObjectKeyword = exports.tsObjectKeyword = tsObjectKeyword;
exports.tSOptionalType = exports.tsOptionalType = tsOptionalType;
exports.tSParameterProperty = exports.tsParameterProperty = tsParameterProperty;
exports.tSParenthesizedType = exports.tsParenthesizedType = tsParenthesizedType;
exports.tSPropertySignature = exports.tsPropertySignature = tsPropertySignature;
exports.tSQualifiedName = exports.tsQualifiedName = tsQualifiedName;
exports.tSRestType = exports.tsRestType = tsRestType;
exports.tSSatisfiesExpression = exports.tsSatisfiesExpression = tsSatisfiesExpression;
exports.tSStringKeyword = exports.tsStringKeyword = tsStringKeyword;
exports.tSSymbolKeyword = exports.tsSymbolKeyword = tsSymbolKeyword;
exports.tSThisType = exports.tsThisType = tsThisType;
exports.tSTupleType = exports.tsTupleType = tsTupleType;
exports.tSTypeAliasDeclaration = exports.tsTypeAliasDeclaration = tsTypeAliasDeclaration;
exports.tSTypeAnnotation = exports.tsTypeAnnotation = tsTypeAnnotation;
exports.tSTypeAssertion = exports.tsTypeAssertion = tsTypeAssertion;
exports.tSTypeLiteral = exports.tsTypeLiteral = tsTypeLiteral;
exports.tSTypeOperator = exports.tsTypeOperator = tsTypeOperator;
exports.tSTypeParameter = exports.tsTypeParameter = tsTypeParameter;
exports.tSTypeParameterDeclaration = exports.tsTypeParameterDeclaration = tsTypeParameterDeclaration;
exports.tSTypeParameterInstantiation = exports.tsTypeParameterInstantiation = tsTypeParameterInstantiation;
exports.tSTypePredicate = exports.tsTypePredicate = tsTypePredicate;
exports.tSTypeQuery = exports.tsTypeQuery = tsTypeQuery;
exports.tSTypeReference = exports.tsTypeReference = tsTypeReference;
exports.tSUndefinedKeyword = exports.tsUndefinedKeyword = tsUndefinedKeyword;
exports.tSUnionType = exports.tsUnionType = tsUnionType;
exports.tSUnknownKeyword = exports.tsUnknownKeyword = tsUnknownKeyword;
exports.tSVoidKeyword = exports.tsVoidKeyword = tsVoidKeyword;
exports.tupleExpression = tupleExpression;
exports.tupleTypeAnnotation = tupleTypeAnnotation;
exports.typeAlias = typeAlias;
exports.typeAnnotation = typeAnnotation;
exports.typeCastExpression = typeCastExpression;
exports.typeParameter = typeParameter;
exports.typeParameterDeclaration = typeParameterDeclaration;
exports.typeParameterInstantiation = typeParameterInstantiation;
exports.typeofTypeAnnotation = typeofTypeAnnotation;
exports.unaryExpression = unaryExpression;
exports.unionTypeAnnotation = unionTypeAnnotation;
exports.updateExpression = updateExpression;
exports.v8IntrinsicIdentifier = v8IntrinsicIdentifier;
exports.variableDeclaration = variableDeclaration;
exports.variableDeclarator = variableDeclarator;
exports.variance = variance;
exports.voidTypeAnnotation = voidTypeAnnotation;
exports.whileStatement = whileStatement;
exports.withStatement = withStatement;
exports.yieldExpression = yieldExpression;

var _validate = require("../../validators/validate.js");

var _deprecationWarning = require("../../utils/deprecationWarning.js");

var utils = require("../../definitions/utils.js");

var validate = _validate.validateInternal;
var NODE_FIELDS = utils.NODE_FIELDS;

function arrayExpression() {
  var elements = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];
  var node = {
    type: "ArrayExpression",
    elements: elements
  };
  var defs = NODE_FIELDS.ArrayExpression;
  validate(defs.elements, node, "elements", elements, 1);
  return node;
}

function assignmentExpression(operator, left, right) {
  var node = {
    type: "AssignmentExpression",
    operator: operator,
    left: left,
    right: right
  };
  var defs = NODE_FIELDS.AssignmentExpression;
  validate(defs.operator, node, "operator", operator);
  validate(defs.left, node, "left", left, 1);
  validate(defs.right, node, "right", right, 1);
  return node;
}

function binaryExpression(operator, left, right) {
  var node = {
    type: "BinaryExpression",
    operator: operator,
    left: left,
    right: right
  };
  var defs = NODE_FIELDS.BinaryExpression;
  validate(defs.operator, node, "operator", operator);
  validate(defs.left, node, "left", left, 1);
  validate(defs.right, node, "right", right, 1);
  return node;
}

function interpreterDirective(value) {
  var node = {
    type: "InterpreterDirective",
    value: value
  };
  var defs = NODE_FIELDS.InterpreterDirective;
  validate(defs.value, node, "value", value);
  return node;
}

function directive(value) {
  var node = {
    type: "Directive",
    value: value
  };
  var defs = NODE_FIELDS.Directive;
  validate(defs.value, node, "value", value, 1);
  return node;
}

function directiveLiteral(value) {
  var node = {
    type: "DirectiveLiteral",
    value: value
  };
  var defs = NODE_FIELDS.DirectiveLiteral;
  validate(defs.value, node, "value", value);
  return node;
}

function blockStatement(body) {
  var directives = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];
  var node = {
    type: "BlockStatement",
    body: body,
    directives: directives
  };
  var defs = NODE_FIELDS.BlockStatement;
  validate(defs.body, node, "body", body, 1);
  validate(defs.directives, node, "directives", directives, 1);
  return node;
}

function breakStatement() {
  var label = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;
  var node = {
    type: "BreakStatement",
    label: label
  };
  var defs = NODE_FIELDS.BreakStatement;
  validate(defs.label, node, "label", label, 1);
  return node;
}

function callExpression(callee, _arguments) {
  var node = {
    type: "CallExpression",
    callee: callee,
    arguments: _arguments
  };
  var defs = NODE_FIELDS.CallExpression;
  validate(defs.callee, node, "callee", callee, 1);
  validate(defs.arguments, node, "arguments", _arguments, 1);
  return node;
}

function catchClause() {
  var param = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;
  var body = arguments.length > 1 ? arguments[1] : undefined;
  var node = {
    type: "CatchClause",
    param: param,
    body: body
  };
  var defs = NODE_FIELDS.CatchClause;
  validate(defs.param, node, "param", param, 1);
  validate(defs.body, node, "body", body, 1);
  return node;
}

function conditionalExpression(test, consequent, alternate) {
  var node = {
    type: "ConditionalExpression",
    test: test,
    consequent: consequent,
    alternate: alternate
  };
  var defs = NODE_FIELDS.ConditionalExpression;
  validate(defs.test, node, "test", test, 1);
  validate(defs.consequent, node, "consequent", consequent, 1);
  validate(defs.alternate, node, "alternate", alternate, 1);
  return node;
}

function continueStatement() {
  var label = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;
  var node = {
    type: "ContinueStatement",
    label: label
  };
  var defs = NODE_FIELDS.ContinueStatement;
  validate(defs.label, node, "label", label, 1);
  return node;
}

function debuggerStatement() {
  return {
    type: "DebuggerStatement"
  };
}

function doWhileStatement(test, body) {
  var node = {
    type: "DoWhileStatement",
    test: test,
    body: body
  };
  var defs = NODE_FIELDS.DoWhileStatement;
  validate(defs.test, node, "test", test, 1);
  validate(defs.body, node, "body", body, 1);
  return node;
}

function emptyStatement() {
  return {
    type: "EmptyStatement"
  };
}

function expressionStatement(expression) {
  var node = {
    type: "ExpressionStatement",
    expression: expression
  };
  var defs = NODE_FIELDS.ExpressionStatement;
  validate(defs.expression, node, "expression", expression, 1);
  return node;
}

function file(program) {
  var comments = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
  var tokens = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;
  var node = {
    type: "File",
    program: program,
    comments: comments,
    tokens: tokens
  };
  var defs = NODE_FIELDS.File;
  validate(defs.program, node, "program", program, 1);
  validate(defs.comments, node, "comments", comments, 1);
  validate(defs.tokens, node, "tokens", tokens);
  return node;
}

function forInStatement(left, right, body) {
  var node = {
    type: "ForInStatement",
    left: left,
    right: right,
    body: body
  };
  var defs = NODE_FIELDS.ForInStatement;
  validate(defs.left, node, "left", left, 1);
  validate(defs.right, node, "right", right, 1);
  validate(defs.body, node, "body", body, 1);
  return node;
}

function forStatement() {
  var init = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;
  var test = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
  var update = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;
  var body = arguments.length > 3 ? arguments[3] : undefined;
  var node = {
    type: "ForStatement",
    init: init,
    test: test,
    update: update,
    body: body
  };
  var defs = NODE_FIELDS.ForStatement;
  validate(defs.init, node, "init", init, 1);
  validate(defs.test, node, "test", test, 1);
  validate(defs.update, node, "update", update, 1);
  validate(defs.body, node, "body", body, 1);
  return node;
}

function functionDeclaration() {
  var id = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;
  var params = arguments.length > 1 ? arguments[1] : undefined;
  var body = arguments.length > 2 ? arguments[2] : undefined;
  var generator = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;
  var async = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : false;
  var node = {
    type: "FunctionDeclaration",
    id: id,
    params: params,
    body: body,
    generator: generator,
    async: async
  };
  var defs = NODE_FIELDS.FunctionDeclaration;
  validate(defs.id, node, "id", id, 1);
  validate(defs.params, node, "params", params, 1);
  validate(defs.body, node, "body", body, 1);
  validate(defs.generator, node, "generator", generator);
  validate(defs.async, node, "async", async);
  return node;
}

function functionExpression() {
  var id = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;
  var params = arguments.length > 1 ? arguments[1] : undefined;
  var body = arguments.length > 2 ? arguments[2] : undefined;
  var generator = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;
  var async = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : false;
  var node = {
    type: "FunctionExpression",
    id: id,
    params: params,
    body: body,
    generator: generator,
    async: async
  };
  var defs = NODE_FIELDS.FunctionExpression;
  validate(defs.id, node, "id", id, 1);
  validate(defs.params, node, "params", params, 1);
  validate(defs.body, node, "body", body, 1);
  validate(defs.generator, node, "generator", generator);
  validate(defs.async, node, "async", async);
  return node;
}

function identifier(name) {
  var node = {
    type: "Identifier",
    name: name
  };
  var defs = NODE_FIELDS.Identifier;
  validate(defs.name, node, "name", name);
  return node;
}

function ifStatement(test, consequent) {
  var alternate = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;
  var node = {
    type: "IfStatement",
    test: test,
    consequent: consequent,
    alternate: alternate
  };
  var defs = NODE_FIELDS.IfStatement;
  validate(defs.test, node, "test", test, 1);
  validate(defs.consequent, node, "consequent", consequent, 1);
  validate(defs.alternate, node, "alternate", alternate, 1);
  return node;
}

function labeledStatement(label, body) {
  var node = {
    type: "LabeledStatement",
    label: label,
    body: body
  };
  var defs = NODE_FIELDS.LabeledStatement;
  validate(defs.label, node, "label", label, 1);
  validate(defs.body, node, "body", body, 1);
  return node;
}

function stringLiteral(value) {
  var node = {
    type: "StringLiteral",
    value: value
  };
  var defs = NODE_FIELDS.StringLiteral;
  validate(defs.value, node, "value", value);
  return node;
}

function numericLiteral(value) {
  var node = {
    type: "NumericLiteral",
    value: value
  };
  var defs = NODE_FIELDS.NumericLiteral;
  validate(defs.value, node, "value", value);
  return node;
}

function nullLiteral() {
  return {
    type: "NullLiteral"
  };
}

function booleanLiteral(value) {
  var node = {
    type: "BooleanLiteral",
    value: value
  };
  var defs = NODE_FIELDS.BooleanLiteral;
  validate(defs.value, node, "value", value);
  return node;
}

function regExpLiteral(pattern) {
  var flags = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : "";
  var node = {
    type: "RegExpLiteral",
    pattern: pattern,
    flags: flags
  };
  var defs = NODE_FIELDS.RegExpLiteral;
  validate(defs.pattern, node, "pattern", pattern);
  validate(defs.flags, node, "flags", flags);
  return node;
}

function logicalExpression(operator, left, right) {
  var node = {
    type: "LogicalExpression",
    operator: operator,
    left: left,
    right: right
  };
  var defs = NODE_FIELDS.LogicalExpression;
  validate(defs.operator, node, "operator", operator);
  validate(defs.left, node, "left", left, 1);
  validate(defs.right, node, "right", right, 1);
  return node;
}

function memberExpression(object, property) {
  var computed = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
  var optional = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;
  var node = {
    type: "MemberExpression",
    object: object,
    property: property,
    computed: computed,
    optional: optional
  };
  var defs = NODE_FIELDS.MemberExpression;
  validate(defs.object, node, "object", object, 1);
  validate(defs.property, node, "property", property, 1);
  validate(defs.computed, node, "computed", computed);
  validate(defs.optional, node, "optional", optional);
  return node;
}

function newExpression(callee, _arguments) {
  var node = {
    type: "NewExpression",
    callee: callee,
    arguments: _arguments
  };
  var defs = NODE_FIELDS.NewExpression;
  validate(defs.callee, node, "callee", callee, 1);
  validate(defs.arguments, node, "arguments", _arguments, 1);
  return node;
}

function program(body) {
  var directives = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];
  var sourceType = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : "script";
  var interpreter = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;
  var node = {
    type: "Program",
    body: body,
    directives: directives,
    sourceType: sourceType,
    interpreter: interpreter
  };
  var defs = NODE_FIELDS.Program;
  validate(defs.body, node, "body", body, 1);
  validate(defs.directives, node, "directives", directives, 1);
  validate(defs.sourceType, node, "sourceType", sourceType);
  validate(defs.interpreter, node, "interpreter", interpreter, 1);
  return node;
}

function objectExpression(properties) {
  var node = {
    type: "ObjectExpression",
    properties: properties
  };
  var defs = NODE_FIELDS.ObjectExpression;
  validate(defs.properties, node, "properties", properties, 1);
  return node;
}

function objectMethod() {
  var kind = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : "method";
  var key = arguments.length > 1 ? arguments[1] : undefined;
  var params = arguments.length > 2 ? arguments[2] : undefined;
  var body = arguments.length > 3 ? arguments[3] : undefined;
  var computed = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : false;
  var generator = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : false;
  var async = arguments.length > 6 && arguments[6] !== undefined ? arguments[6] : false;
  var node = {
    type: "ObjectMethod",
    kind: kind,
    key: key,
    params: params,
    body: body,
    computed: computed,
    generator: generator,
    async: async
  };
  var defs = NODE_FIELDS.ObjectMethod;
  validate(defs.kind, node, "kind", kind);
  validate(defs.key, node, "key", key, 1);
  validate(defs.params, node, "params", params, 1);
  validate(defs.body, node, "body", body, 1);
  validate(defs.computed, node, "computed", computed);
  validate(defs.generator, node, "generator", generator);
  validate(defs.async, node, "async", async);
  return node;
}

function objectProperty(key, value) {
  var computed = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
  var shorthand = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;
  var decorators = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : null;
  var node = {
    type: "ObjectProperty",
    key: key,
    value: value,
    computed: computed,
    shorthand: shorthand,
    decorators: decorators
  };
  var defs = NODE_FIELDS.ObjectProperty;
  validate(defs.key, node, "key", key, 1);
  validate(defs.value, node, "value", value, 1);
  validate(defs.computed, node, "computed", computed);
  validate(defs.shorthand, node, "shorthand", shorthand);
  validate(defs.decorators, node, "decorators", decorators, 1);
  return node;
}

function restElement(argument) {
  var node = {
    type: "RestElement",
    argument: argument
  };
  var defs = NODE_FIELDS.RestElement;
  validate(defs.argument, node, "argument", argument, 1);
  return node;
}

function returnStatement() {
  var argument = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;
  var node = {
    type: "ReturnStatement",
    argument: argument
  };
  var defs = NODE_FIELDS.ReturnStatement;
  validate(defs.argument, node, "argument", argument, 1);
  return node;
}

function sequenceExpression(expressions) {
  var node = {
    type: "SequenceExpression",
    expressions: expressions
  };
  var defs = NODE_FIELDS.SequenceExpression;
  validate(defs.expressions, node, "expressions", expressions, 1);
  return node;
}

function parenthesizedExpression(expression) {
  var node = {
    type: "ParenthesizedExpression",
    expression: expression
  };
  var defs = NODE_FIELDS.ParenthesizedExpression;
  validate(defs.expression, node, "expression", expression, 1);
  return node;
}

function switchCase() {
  var test = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;
  var consequent = arguments.length > 1 ? arguments[1] : undefined;
  var node = {
    type: "SwitchCase",
    test: test,
    consequent: consequent
  };
  var defs = NODE_FIELDS.SwitchCase;
  validate(defs.test, node, "test", test, 1);
  validate(defs.consequent, node, "consequent", consequent, 1);
  return node;
}

function switchStatement(discriminant, cases) {
  var node = {
    type: "SwitchStatement",
    discriminant: discriminant,
    cases: cases
  };
  var defs = NODE_FIELDS.SwitchStatement;
  validate(defs.discriminant, node, "discriminant", discriminant, 1);
  validate(defs.cases, node, "cases", cases, 1);
  return node;
}

function thisExpression() {
  return {
    type: "ThisExpression"
  };
}

function throwStatement(argument) {
  var node = {
    type: "ThrowStatement",
    argument: argument
  };
  var defs = NODE_FIELDS.ThrowStatement;
  validate(defs.argument, node, "argument", argument, 1);
  return node;
}

function tryStatement(block) {
  var handler = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
  var finalizer = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;
  var node = {
    type: "TryStatement",
    block: block,
    handler: handler,
    finalizer: finalizer
  };
  var defs = NODE_FIELDS.TryStatement;
  validate(defs.block, node, "block", block, 1);
  validate(defs.handler, node, "handler", handler, 1);
  validate(defs.finalizer, node, "finalizer", finalizer, 1);
  return node;
}

function unaryExpression(operator, argument) {
  var prefix = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;
  var node = {
    type: "UnaryExpression",
    operator: operator,
    argument: argument,
    prefix: prefix
  };
  var defs = NODE_FIELDS.UnaryExpression;
  validate(defs.operator, node, "operator", operator);
  validate(defs.argument, node, "argument", argument, 1);
  validate(defs.prefix, node, "prefix", prefix);
  return node;
}

function updateExpression(operator, argument) {
  var prefix = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
  var node = {
    type: "UpdateExpression",
    operator: operator,
    argument: argument,
    prefix: prefix
  };
  var defs = NODE_FIELDS.UpdateExpression;
  validate(defs.operator, node, "operator", operator);
  validate(defs.argument, node, "argument", argument, 1);
  validate(defs.prefix, node, "prefix", prefix);
  return node;
}

function variableDeclaration(kind, declarations) {
  var node = {
    type: "VariableDeclaration",
    kind: kind,
    declarations: declarations
  };
  var defs = NODE_FIELDS.VariableDeclaration;
  validate(defs.kind, node, "kind", kind);
  validate(defs.declarations, node, "declarations", declarations, 1);
  return node;
}

function variableDeclarator(id) {
  var init = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
  var node = {
    type: "VariableDeclarator",
    id: id,
    init: init
  };
  var defs = NODE_FIELDS.VariableDeclarator;
  validate(defs.id, node, "id", id, 1);
  validate(defs.init, node, "init", init, 1);
  return node;
}

function whileStatement(test, body) {
  var node = {
    type: "WhileStatement",
    test: test,
    body: body
  };
  var defs = NODE_FIELDS.WhileStatement;
  validate(defs.test, node, "test", test, 1);
  validate(defs.body, node, "body", body, 1);
  return node;
}

function withStatement(object, body) {
  var node = {
    type: "WithStatement",
    object: object,
    body: body
  };
  var defs = NODE_FIELDS.WithStatement;
  validate(defs.object, node, "object", object, 1);
  validate(defs.body, node, "body", body, 1);
  return node;
}

function assignmentPattern(left, right) {
  var node = {
    type: "AssignmentPattern",
    left: left,
    right: right
  };
  var defs = NODE_FIELDS.AssignmentPattern;
  validate(defs.left, node, "left", left, 1);
  validate(defs.right, node, "right", right, 1);
  return node;
}

function arrayPattern(elements) {
  var node = {
    type: "ArrayPattern",
    elements: elements
  };
  var defs = NODE_FIELDS.ArrayPattern;
  validate(defs.elements, node, "elements", elements, 1);
  return node;
}

function arrowFunctionExpression(params, body) {
  var async = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
  var node = {
    type: "ArrowFunctionExpression",
    params: params,
    body: body,
    async: async,
    expression: null
  };
  var defs = NODE_FIELDS.ArrowFunctionExpression;
  validate(defs.params, node, "params", params, 1);
  validate(defs.body, node, "body", body, 1);
  validate(defs.async, node, "async", async);
  return node;
}

function classBody(body) {
  var node = {
    type: "ClassBody",
    body: body
  };
  var defs = NODE_FIELDS.ClassBody;
  validate(defs.body, node, "body", body, 1);
  return node;
}

function classExpression() {
  var id = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;
  var superClass = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
  var body = arguments.length > 2 ? arguments[2] : undefined;
  var decorators = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;
  var node = {
    type: "ClassExpression",
    id: id,
    superClass: superClass,
    body: body,
    decorators: decorators
  };
  var defs = NODE_FIELDS.ClassExpression;
  validate(defs.id, node, "id", id, 1);
  validate(defs.superClass, node, "superClass", superClass, 1);
  validate(defs.body, node, "body", body, 1);
  validate(defs.decorators, node, "decorators", decorators, 1);
  return node;
}

function classDeclaration() {
  var id = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;
  var superClass = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
  var body = arguments.length > 2 ? arguments[2] : undefined;
  var decorators = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;
  var node = {
    type: "ClassDeclaration",
    id: id,
    superClass: superClass,
    body: body,
    decorators: decorators
  };
  var defs = NODE_FIELDS.ClassDeclaration;
  validate(defs.id, node, "id", id, 1);
  validate(defs.superClass, node, "superClass", superClass, 1);
  validate(defs.body, node, "body", body, 1);
  validate(defs.decorators, node, "decorators", decorators, 1);
  return node;
}

function exportAllDeclaration(source) {
  var node = {
    type: "ExportAllDeclaration",
    source: source
  };
  var defs = NODE_FIELDS.ExportAllDeclaration;
  validate(defs.source, node, "source", source, 1);
  return node;
}

function exportDefaultDeclaration(declaration) {
  var node = {
    type: "ExportDefaultDeclaration",
    declaration: declaration
  };
  var defs = NODE_FIELDS.ExportDefaultDeclaration;
  validate(defs.declaration, node, "declaration", declaration, 1);
  return node;
}

function exportNamedDeclaration() {
  var declaration = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;
  var specifiers = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];
  var source = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;
  var node = {
    type: "ExportNamedDeclaration",
    declaration: declaration,
    specifiers: specifiers,
    source: source
  };
  var defs = NODE_FIELDS.ExportNamedDeclaration;
  validate(defs.declaration, node, "declaration", declaration, 1);
  validate(defs.specifiers, node, "specifiers", specifiers, 1);
  validate(defs.source, node, "source", source, 1);
  return node;
}

function exportSpecifier(local, exported) {
  var node = {
    type: "ExportSpecifier",
    local: local,
    exported: exported
  };
  var defs = NODE_FIELDS.ExportSpecifier;
  validate(defs.local, node, "local", local, 1);
  validate(defs.exported, node, "exported", exported, 1);
  return node;
}

function forOfStatement(left, right, body) {
  var _await = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;

  var node = {
    type: "ForOfStatement",
    left: left,
    right: right,
    body: body,
    "await": _await
  };
  var defs = NODE_FIELDS.ForOfStatement;
  validate(defs.left, node, "left", left, 1);
  validate(defs.right, node, "right", right, 1);
  validate(defs.body, node, "body", body, 1);
  validate(defs["await"], node, "await", _await);
  return node;
}

function importDeclaration(specifiers, source) {
  var node = {
    type: "ImportDeclaration",
    specifiers: specifiers,
    source: source
  };
  var defs = NODE_FIELDS.ImportDeclaration;
  validate(defs.specifiers, node, "specifiers", specifiers, 1);
  validate(defs.source, node, "source", source, 1);
  return node;
}

function importDefaultSpecifier(local) {
  var node = {
    type: "ImportDefaultSpecifier",
    local: local
  };
  var defs = NODE_FIELDS.ImportDefaultSpecifier;
  validate(defs.local, node, "local", local, 1);
  return node;
}

function importNamespaceSpecifier(local) {
  var node = {
    type: "ImportNamespaceSpecifier",
    local: local
  };
  var defs = NODE_FIELDS.ImportNamespaceSpecifier;
  validate(defs.local, node, "local", local, 1);
  return node;
}

function importSpecifier(local, imported) {
  var node = {
    type: "ImportSpecifier",
    local: local,
    imported: imported
  };
  var defs = NODE_FIELDS.ImportSpecifier;
  validate(defs.local, node, "local", local, 1);
  validate(defs.imported, node, "imported", imported, 1);
  return node;
}

function importExpression(source) {
  var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
  var node = {
    type: "ImportExpression",
    source: source,
    options: options
  };
  var defs = NODE_FIELDS.ImportExpression;
  validate(defs.source, node, "source", source, 1);
  validate(defs.options, node, "options", options, 1);
  return node;
}

function metaProperty(meta, property) {
  var node = {
    type: "MetaProperty",
    meta: meta,
    property: property
  };
  var defs = NODE_FIELDS.MetaProperty;
  validate(defs.meta, node, "meta", meta, 1);
  validate(defs.property, node, "property", property, 1);
  return node;
}

function classMethod() {
  var kind = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : "method";
  var key = arguments.length > 1 ? arguments[1] : undefined;
  var params = arguments.length > 2 ? arguments[2] : undefined;
  var body = arguments.length > 3 ? arguments[3] : undefined;
  var computed = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : false;

  var _static = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : false;

  var generator = arguments.length > 6 && arguments[6] !== undefined ? arguments[6] : false;
  var async = arguments.length > 7 && arguments[7] !== undefined ? arguments[7] : false;
  var node = {
    type: "ClassMethod",
    kind: kind,
    key: key,
    params: params,
    body: body,
    computed: computed,
    "static": _static,
    generator: generator,
    async: async
  };
  var defs = NODE_FIELDS.ClassMethod;
  validate(defs.kind, node, "kind", kind);
  validate(defs.key, node, "key", key, 1);
  validate(defs.params, node, "params", params, 1);
  validate(defs.body, node, "body", body, 1);
  validate(defs.computed, node, "computed", computed);
  validate(defs["static"], node, "static", _static);
  validate(defs.generator, node, "generator", generator);
  validate(defs.async, node, "async", async);
  return node;
}

function objectPattern(properties) {
  var node = {
    type: "ObjectPattern",
    properties: properties
  };
  var defs = NODE_FIELDS.ObjectPattern;
  validate(defs.properties, node, "properties", properties, 1);
  return node;
}

function spreadElement(argument) {
  var node = {
    type: "SpreadElement",
    argument: argument
  };
  var defs = NODE_FIELDS.SpreadElement;
  validate(defs.argument, node, "argument", argument, 1);
  return node;
}

function _super() {
  return {
    type: "Super"
  };
}

function taggedTemplateExpression(tag, quasi) {
  var node = {
    type: "TaggedTemplateExpression",
    tag: tag,
    quasi: quasi
  };
  var defs = NODE_FIELDS.TaggedTemplateExpression;
  validate(defs.tag, node, "tag", tag, 1);
  validate(defs.quasi, node, "quasi", quasi, 1);
  return node;
}

function templateElement(value) {
  var tail = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
  var node = {
    type: "TemplateElement",
    value: value,
    tail: tail
  };
  var defs = NODE_FIELDS.TemplateElement;
  validate(defs.value, node, "value", value);
  validate(defs.tail, node, "tail", tail);
  return node;
}

function templateLiteral(quasis, expressions) {
  var node = {
    type: "TemplateLiteral",
    quasis: quasis,
    expressions: expressions
  };
  var defs = NODE_FIELDS.TemplateLiteral;
  validate(defs.quasis, node, "quasis", quasis, 1);
  validate(defs.expressions, node, "expressions", expressions, 1);
  return node;
}

function yieldExpression() {
  var argument = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;
  var delegate = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
  var node = {
    type: "YieldExpression",
    argument: argument,
    delegate: delegate
  };
  var defs = NODE_FIELDS.YieldExpression;
  validate(defs.argument, node, "argument", argument, 1);
  validate(defs.delegate, node, "delegate", delegate);
  return node;
}

function awaitExpression(argument) {
  var node = {
    type: "AwaitExpression",
    argument: argument
  };
  var defs = NODE_FIELDS.AwaitExpression;
  validate(defs.argument, node, "argument", argument, 1);
  return node;
}

function _import() {
  return {
    type: "Import"
  };
}

function bigIntLiteral(value) {
  var node = {
    type: "BigIntLiteral",
    value: value
  };
  var defs = NODE_FIELDS.BigIntLiteral;
  validate(defs.value, node, "value", value);
  return node;
}

function exportNamespaceSpecifier(exported) {
  var node = {
    type: "ExportNamespaceSpecifier",
    exported: exported
  };
  var defs = NODE_FIELDS.ExportNamespaceSpecifier;
  validate(defs.exported, node, "exported", exported, 1);
  return node;
}

function optionalMemberExpression(object, property) {
  var computed = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
  var optional = arguments.length > 3 ? arguments[3] : undefined;
  var node = {
    type: "OptionalMemberExpression",
    object: object,
    property: property,
    computed: computed,
    optional: optional
  };
  var defs = NODE_FIELDS.OptionalMemberExpression;
  validate(defs.object, node, "object", object, 1);
  validate(defs.property, node, "property", property, 1);
  validate(defs.computed, node, "computed", computed);
  validate(defs.optional, node, "optional", optional);
  return node;
}

function optionalCallExpression(callee, _arguments, optional) {
  var node = {
    type: "OptionalCallExpression",
    callee: callee,
    arguments: _arguments,
    optional: optional
  };
  var defs = NODE_FIELDS.OptionalCallExpression;
  validate(defs.callee, node, "callee", callee, 1);
  validate(defs.arguments, node, "arguments", _arguments, 1);
  validate(defs.optional, node, "optional", optional);
  return node;
}

function classProperty(key) {
  var value = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
  var typeAnnotation = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;
  var decorators = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;
  var computed = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : false;

  var _static = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : false;

  var node = {
    type: "ClassProperty",
    key: key,
    value: value,
    typeAnnotation: typeAnnotation,
    decorators: decorators,
    computed: computed,
    "static": _static
  };
  var defs = NODE_FIELDS.ClassProperty;
  validate(defs.key, node, "key", key, 1);
  validate(defs.value, node, "value", value, 1);
  validate(defs.typeAnnotation, node, "typeAnnotation", typeAnnotation, 1);
  validate(defs.decorators, node, "decorators", decorators, 1);
  validate(defs.computed, node, "computed", computed);
  validate(defs["static"], node, "static", _static);
  return node;
}

function classAccessorProperty(key) {
  var value = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
  var typeAnnotation = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;
  var decorators = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;
  var computed = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : false;

  var _static = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : false;

  var node = {
    type: "ClassAccessorProperty",
    key: key,
    value: value,
    typeAnnotation: typeAnnotation,
    decorators: decorators,
    computed: computed,
    "static": _static
  };
  var defs = NODE_FIELDS.ClassAccessorProperty;
  validate(defs.key, node, "key", key, 1);
  validate(defs.value, node, "value", value, 1);
  validate(defs.typeAnnotation, node, "typeAnnotation", typeAnnotation, 1);
  validate(defs.decorators, node, "decorators", decorators, 1);
  validate(defs.computed, node, "computed", computed);
  validate(defs["static"], node, "static", _static);
  return node;
}

function classPrivateProperty(key) {
  var value = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
  var decorators = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;

  var _static = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;

  var node = {
    type: "ClassPrivateProperty",
    key: key,
    value: value,
    decorators: decorators,
    "static": _static
  };
  var defs = NODE_FIELDS.ClassPrivateProperty;
  validate(defs.key, node, "key", key, 1);
  validate(defs.value, node, "value", value, 1);
  validate(defs.decorators, node, "decorators", decorators, 1);
  validate(defs["static"], node, "static", _static);
  return node;
}

function classPrivateMethod() {
  var kind = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : "method";
  var key = arguments.length > 1 ? arguments[1] : undefined;
  var params = arguments.length > 2 ? arguments[2] : undefined;
  var body = arguments.length > 3 ? arguments[3] : undefined;

  var _static = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : false;

  var node = {
    type: "ClassPrivateMethod",
    kind: kind,
    key: key,
    params: params,
    body: body,
    "static": _static
  };
  var defs = NODE_FIELDS.ClassPrivateMethod;
  validate(defs.kind, node, "kind", kind);
  validate(defs.key, node, "key", key, 1);
  validate(defs.params, node, "params", params, 1);
  validate(defs.body, node, "body", body, 1);
  validate(defs["static"], node, "static", _static);
  return node;
}

function privateName(id) {
  var node = {
    type: "PrivateName",
    id: id
  };
  var defs = NODE_FIELDS.PrivateName;
  validate(defs.id, node, "id", id, 1);
  return node;
}

function staticBlock(body) {
  var node = {
    type: "StaticBlock",
    body: body
  };
  var defs = NODE_FIELDS.StaticBlock;
  validate(defs.body, node, "body", body, 1);
  return node;
}

function anyTypeAnnotation() {
  return {
    type: "AnyTypeAnnotation"
  };
}

function arrayTypeAnnotation(elementType) {
  var node = {
    type: "ArrayTypeAnnotation",
    elementType: elementType
  };
  var defs = NODE_FIELDS.ArrayTypeAnnotation;
  validate(defs.elementType, node, "elementType", elementType, 1);
  return node;
}

function booleanTypeAnnotation() {
  return {
    type: "BooleanTypeAnnotation"
  };
}

function booleanLiteralTypeAnnotation(value) {
  var node = {
    type: "BooleanLiteralTypeAnnotation",
    value: value
  };
  var defs = NODE_FIELDS.BooleanLiteralTypeAnnotation;
  validate(defs.value, node, "value", value);
  return node;
}

function nullLiteralTypeAnnotation() {
  return {
    type: "NullLiteralTypeAnnotation"
  };
}

function classImplements(id) {
  var typeParameters = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
  var node = {
    type: "ClassImplements",
    id: id,
    typeParameters: typeParameters
  };
  var defs = NODE_FIELDS.ClassImplements;
  validate(defs.id, node, "id", id, 1);
  validate(defs.typeParameters, node, "typeParameters", typeParameters, 1);
  return node;
}

function declareClass(id) {
  var typeParameters = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;

  var _extends = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;

  var body = arguments.length > 3 ? arguments[3] : undefined;
  var node = {
    type: "DeclareClass",
    id: id,
    typeParameters: typeParameters,
    "extends": _extends,
    body: body
  };
  var defs = NODE_FIELDS.DeclareClass;
  validate(defs.id, node, "id", id, 1);
  validate(defs.typeParameters, node, "typeParameters", typeParameters, 1);
  validate(defs["extends"], node, "extends", _extends, 1);
  validate(defs.body, node, "body", body, 1);
  return node;
}

function declareFunction(id) {
  var node = {
    type: "DeclareFunction",
    id: id
  };
  var defs = NODE_FIELDS.DeclareFunction;
  validate(defs.id, node, "id", id, 1);
  return node;
}

function declareInterface(id) {
  var typeParameters = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;

  var _extends = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;

  var body = arguments.length > 3 ? arguments[3] : undefined;
  var node = {
    type: "DeclareInterface",
    id: id,
    typeParameters: typeParameters,
    "extends": _extends,
    body: body
  };
  var defs = NODE_FIELDS.DeclareInterface;
  validate(defs.id, node, "id", id, 1);
  validate(defs.typeParameters, node, "typeParameters", typeParameters, 1);
  validate(defs["extends"], node, "extends", _extends, 1);
  validate(defs.body, node, "body", body, 1);
  return node;
}

function declareModule(id, body) {
  var kind = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;
  var node = {
    type: "DeclareModule",
    id: id,
    body: body,
    kind: kind
  };
  var defs = NODE_FIELDS.DeclareModule;
  validate(defs.id, node, "id", id, 1);
  validate(defs.body, node, "body", body, 1);
  validate(defs.kind, node, "kind", kind);
  return node;
}

function declareModuleExports(typeAnnotation) {
  var node = {
    type: "DeclareModuleExports",
    typeAnnotation: typeAnnotation
  };
  var defs = NODE_FIELDS.DeclareModuleExports;
  validate(defs.typeAnnotation, node, "typeAnnotation", typeAnnotation, 1);
  return node;
}

function declareTypeAlias(id) {
  var typeParameters = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
  var right = arguments.length > 2 ? arguments[2] : undefined;
  var node = {
    type: "DeclareTypeAlias",
    id: id,
    typeParameters: typeParameters,
    right: right
  };
  var defs = NODE_FIELDS.DeclareTypeAlias;
  validate(defs.id, node, "id", id, 1);
  validate(defs.typeParameters, node, "typeParameters", typeParameters, 1);
  validate(defs.right, node, "right", right, 1);
  return node;
}

function declareOpaqueType(id) {
  var typeParameters = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
  var supertype = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;
  var node = {
    type: "DeclareOpaqueType",
    id: id,
    typeParameters: typeParameters,
    supertype: supertype
  };
  var defs = NODE_FIELDS.DeclareOpaqueType;
  validate(defs.id, node, "id", id, 1);
  validate(defs.typeParameters, node, "typeParameters", typeParameters, 1);
  validate(defs.supertype, node, "supertype", supertype, 1);
  return node;
}

function declareVariable(id) {
  var node = {
    type: "DeclareVariable",
    id: id
  };
  var defs = NODE_FIELDS.DeclareVariable;
  validate(defs.id, node, "id", id, 1);
  return node;
}

function declareExportDeclaration() {
  var declaration = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;
  var specifiers = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
  var source = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;
  var node = {
    type: "DeclareExportDeclaration",
    declaration: declaration,
    specifiers: specifiers,
    source: source
  };
  var defs = NODE_FIELDS.DeclareExportDeclaration;
  validate(defs.declaration, node, "declaration", declaration, 1);
  validate(defs.specifiers, node, "specifiers", specifiers, 1);
  validate(defs.source, node, "source", source, 1);
  return node;
}

function declareExportAllDeclaration(source) {
  var node = {
    type: "DeclareExportAllDeclaration",
    source: source
  };
  var defs = NODE_FIELDS.DeclareExportAllDeclaration;
  validate(defs.source, node, "source", source, 1);
  return node;
}

function declaredPredicate(value) {
  var node = {
    type: "DeclaredPredicate",
    value: value
  };
  var defs = NODE_FIELDS.DeclaredPredicate;
  validate(defs.value, node, "value", value, 1);
  return node;
}

function existsTypeAnnotation() {
  return {
    type: "ExistsTypeAnnotation"
  };
}

function functionTypeAnnotation() {
  var typeParameters = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;
  var params = arguments.length > 1 ? arguments[1] : undefined;
  var rest = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;
  var returnType = arguments.length > 3 ? arguments[3] : undefined;
  var node = {
    type: "FunctionTypeAnnotation",
    typeParameters: typeParameters,
    params: params,
    rest: rest,
    returnType: returnType
  };
  var defs = NODE_FIELDS.FunctionTypeAnnotation;
  validate(defs.typeParameters, node, "typeParameters", typeParameters, 1);
  validate(defs.params, node, "params", params, 1);
  validate(defs.rest, node, "rest", rest, 1);
  validate(defs.returnType, node, "returnType", returnType, 1);
  return node;
}

function functionTypeParam() {
  var name = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;
  var typeAnnotation = arguments.length > 1 ? arguments[1] : undefined;
  var node = {
    type: "FunctionTypeParam",
    name: name,
    typeAnnotation: typeAnnotation
  };
  var defs = NODE_FIELDS.FunctionTypeParam;
  validate(defs.name, node, "name", name, 1);
  validate(defs.typeAnnotation, node, "typeAnnotation", typeAnnotation, 1);
  return node;
}

function genericTypeAnnotation(id) {
  var typeParameters = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
  var node = {
    type: "GenericTypeAnnotation",
    id: id,
    typeParameters: typeParameters
  };
  var defs = NODE_FIELDS.GenericTypeAnnotation;
  validate(defs.id, node, "id", id, 1);
  validate(defs.typeParameters, node, "typeParameters", typeParameters, 1);
  return node;
}

function inferredPredicate() {
  return {
    type: "InferredPredicate"
  };
}

function interfaceExtends(id) {
  var typeParameters = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
  var node = {
    type: "InterfaceExtends",
    id: id,
    typeParameters: typeParameters
  };
  var defs = NODE_FIELDS.InterfaceExtends;
  validate(defs.id, node, "id", id, 1);
  validate(defs.typeParameters, node, "typeParameters", typeParameters, 1);
  return node;
}

function interfaceDeclaration(id) {
  var typeParameters = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;

  var _extends = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;

  var body = arguments.length > 3 ? arguments[3] : undefined;
  var node = {
    type: "InterfaceDeclaration",
    id: id,
    typeParameters: typeParameters,
    "extends": _extends,
    body: body
  };
  var defs = NODE_FIELDS.InterfaceDeclaration;
  validate(defs.id, node, "id", id, 1);
  validate(defs.typeParameters, node, "typeParameters", typeParameters, 1);
  validate(defs["extends"], node, "extends", _extends, 1);
  validate(defs.body, node, "body", body, 1);
  return node;
}

function interfaceTypeAnnotation() {
  var _extends = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;

  var body = arguments.length > 1 ? arguments[1] : undefined;
  var node = {
    type: "InterfaceTypeAnnotation",
    "extends": _extends,
    body: body
  };
  var defs = NODE_FIELDS.InterfaceTypeAnnotation;
  validate(defs["extends"], node, "extends", _extends, 1);
  validate(defs.body, node, "body", body, 1);
  return node;
}

function intersectionTypeAnnotation(types) {
  var node = {
    type: "IntersectionTypeAnnotation",
    types: types
  };
  var defs = NODE_FIELDS.IntersectionTypeAnnotation;
  validate(defs.types, node, "types", types, 1);
  return node;
}

function mixedTypeAnnotation() {
  return {
    type: "MixedTypeAnnotation"
  };
}

function emptyTypeAnnotation() {
  return {
    type: "EmptyTypeAnnotation"
  };
}

function nullableTypeAnnotation(typeAnnotation) {
  var node = {
    type: "NullableTypeAnnotation",
    typeAnnotation: typeAnnotation
  };
  var defs = NODE_FIELDS.NullableTypeAnnotation;
  validate(defs.typeAnnotation, node, "typeAnnotation", typeAnnotation, 1);
  return node;
}

function numberLiteralTypeAnnotation(value) {
  var node = {
    type: "NumberLiteralTypeAnnotation",
    value: value
  };
  var defs = NODE_FIELDS.NumberLiteralTypeAnnotation;
  validate(defs.value, node, "value", value);
  return node;
}

function numberTypeAnnotation() {
  return {
    type: "NumberTypeAnnotation"
  };
}

function objectTypeAnnotation(properties) {
  var indexers = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];
  var callProperties = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : [];
  var internalSlots = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : [];
  var exact = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : false;
  var node = {
    type: "ObjectTypeAnnotation",
    properties: properties,
    indexers: indexers,
    callProperties: callProperties,
    internalSlots: internalSlots,
    exact: exact
  };
  var defs = NODE_FIELDS.ObjectTypeAnnotation;
  validate(defs.properties, node, "properties", properties, 1);
  validate(defs.indexers, node, "indexers", indexers, 1);
  validate(defs.callProperties, node, "callProperties", callProperties, 1);
  validate(defs.internalSlots, node, "internalSlots", internalSlots, 1);
  validate(defs.exact, node, "exact", exact);
  return node;
}

function objectTypeInternalSlot(id, value, optional, _static, method) {
  var node = {
    type: "ObjectTypeInternalSlot",
    id: id,
    value: value,
    optional: optional,
    "static": _static,
    method: method
  };
  var defs = NODE_FIELDS.ObjectTypeInternalSlot;
  validate(defs.id, node, "id", id, 1);
  validate(defs.value, node, "value", value, 1);
  validate(defs.optional, node, "optional", optional);
  validate(defs["static"], node, "static", _static);
  validate(defs.method, node, "method", method);
  return node;
}

function objectTypeCallProperty(value) {
  var node = {
    type: "ObjectTypeCallProperty",
    value: value,
    "static": null
  };
  var defs = NODE_FIELDS.ObjectTypeCallProperty;
  validate(defs.value, node, "value", value, 1);
  return node;
}

function objectTypeIndexer() {
  var id = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;
  var key = arguments.length > 1 ? arguments[1] : undefined;
  var value = arguments.length > 2 ? arguments[2] : undefined;
  var variance = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;
  var node = {
    type: "ObjectTypeIndexer",
    id: id,
    key: key,
    value: value,
    variance: variance,
    "static": null
  };
  var defs = NODE_FIELDS.ObjectTypeIndexer;
  validate(defs.id, node, "id", id, 1);
  validate(defs.key, node, "key", key, 1);
  validate(defs.value, node, "value", value, 1);
  validate(defs.variance, node, "variance", variance, 1);
  return node;
}

function objectTypeProperty(key, value) {
  var variance = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;
  var node = {
    type: "ObjectTypeProperty",
    key: key,
    value: value,
    variance: variance,
    kind: null,
    method: null,
    optional: null,
    proto: null,
    "static": null
  };
  var defs = NODE_FIELDS.ObjectTypeProperty;
  validate(defs.key, node, "key", key, 1);
  validate(defs.value, node, "value", value, 1);
  validate(defs.variance, node, "variance", variance, 1);
  return node;
}

function objectTypeSpreadProperty(argument) {
  var node = {
    type: "ObjectTypeSpreadProperty",
    argument: argument
  };
  var defs = NODE_FIELDS.ObjectTypeSpreadProperty;
  validate(defs.argument, node, "argument", argument, 1);
  return node;
}

function opaqueType(id) {
  var typeParameters = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
  var supertype = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;
  var impltype = arguments.length > 3 ? arguments[3] : undefined;
  var node = {
    type: "OpaqueType",
    id: id,
    typeParameters: typeParameters,
    supertype: supertype,
    impltype: impltype
  };
  var defs = NODE_FIELDS.OpaqueType;
  validate(defs.id, node, "id", id, 1);
  validate(defs.typeParameters, node, "typeParameters", typeParameters, 1);
  validate(defs.supertype, node, "supertype", supertype, 1);
  validate(defs.impltype, node, "impltype", impltype, 1);
  return node;
}

function qualifiedTypeIdentifier(id, qualification) {
  var node = {
    type: "QualifiedTypeIdentifier",
    id: id,
    qualification: qualification
  };
  var defs = NODE_FIELDS.QualifiedTypeIdentifier;
  validate(defs.id, node, "id", id, 1);
  validate(defs.qualification, node, "qualification", qualification, 1);
  return node;
}

function stringLiteralTypeAnnotation(value) {
  var node = {
    type: "StringLiteralTypeAnnotation",
    value: value
  };
  var defs = NODE_FIELDS.StringLiteralTypeAnnotation;
  validate(defs.value, node, "value", value);
  return node;
}

function stringTypeAnnotation() {
  return {
    type: "StringTypeAnnotation"
  };
}

function symbolTypeAnnotation() {
  return {
    type: "SymbolTypeAnnotation"
  };
}

function thisTypeAnnotation() {
  return {
    type: "ThisTypeAnnotation"
  };
}

function tupleTypeAnnotation(types) {
  var node = {
    type: "TupleTypeAnnotation",
    types: types
  };
  var defs = NODE_FIELDS.TupleTypeAnnotation;
  validate(defs.types, node, "types", types, 1);
  return node;
}

function typeofTypeAnnotation(argument) {
  var node = {
    type: "TypeofTypeAnnotation",
    argument: argument
  };
  var defs = NODE_FIELDS.TypeofTypeAnnotation;
  validate(defs.argument, node, "argument", argument, 1);
  return node;
}

function typeAlias(id) {
  var typeParameters = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
  var right = arguments.length > 2 ? arguments[2] : undefined;
  var node = {
    type: "TypeAlias",
    id: id,
    typeParameters: typeParameters,
    right: right
  };
  var defs = NODE_FIELDS.TypeAlias;
  validate(defs.id, node, "id", id, 1);
  validate(defs.typeParameters, node, "typeParameters", typeParameters, 1);
  validate(defs.right, node, "right", right, 1);
  return node;
}

function typeAnnotation(typeAnnotation) {
  var node = {
    type: "TypeAnnotation",
    typeAnnotation: typeAnnotation
  };
  var defs = NODE_FIELDS.TypeAnnotation;
  validate(defs.typeAnnotation, node, "typeAnnotation", typeAnnotation, 1);
  return node;
}

function typeCastExpression(expression, typeAnnotation) {
  var node = {
    type: "TypeCastExpression",
    expression: expression,
    typeAnnotation: typeAnnotation
  };
  var defs = NODE_FIELDS.TypeCastExpression;
  validate(defs.expression, node, "expression", expression, 1);
  validate(defs.typeAnnotation, node, "typeAnnotation", typeAnnotation, 1);
  return node;
}

function typeParameter() {
  var bound = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;

  var _default = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;

  var variance = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;
  var node = {
    type: "TypeParameter",
    bound: bound,
    "default": _default,
    variance: variance,
    name: null
  };
  var defs = NODE_FIELDS.TypeParameter;
  validate(defs.bound, node, "bound", bound, 1);
  validate(defs["default"], node, "default", _default, 1);
  validate(defs.variance, node, "variance", variance, 1);
  return node;
}

function typeParameterDeclaration(params) {
  var node = {
    type: "TypeParameterDeclaration",
    params: params
  };
  var defs = NODE_FIELDS.TypeParameterDeclaration;
  validate(defs.params, node, "params", params, 1);
  return node;
}

function typeParameterInstantiation(params) {
  var node = {
    type: "TypeParameterInstantiation",
    params: params
  };
  var defs = NODE_FIELDS.TypeParameterInstantiation;
  validate(defs.params, node, "params", params, 1);
  return node;
}

function unionTypeAnnotation(types) {
  var node = {
    type: "UnionTypeAnnotation",
    types: types
  };
  var defs = NODE_FIELDS.UnionTypeAnnotation;
  validate(defs.types, node, "types", types, 1);
  return node;
}

function variance(kind) {
  var node = {
    type: "Variance",
    kind: kind
  };
  var defs = NODE_FIELDS.Variance;
  validate(defs.kind, node, "kind", kind);
  return node;
}

function voidTypeAnnotation() {
  return {
    type: "VoidTypeAnnotation"
  };
}

function enumDeclaration(id, body) {
  var node = {
    type: "EnumDeclaration",
    id: id,
    body: body
  };
  var defs = NODE_FIELDS.EnumDeclaration;
  validate(defs.id, node, "id", id, 1);
  validate(defs.body, node, "body", body, 1);
  return node;
}

function enumBooleanBody(members) {
  var node = {
    type: "EnumBooleanBody",
    members: members,
    explicitType: null,
    hasUnknownMembers: null
  };
  var defs = NODE_FIELDS.EnumBooleanBody;
  validate(defs.members, node, "members", members, 1);
  return node;
}

function enumNumberBody(members) {
  var node = {
    type: "EnumNumberBody",
    members: members,
    explicitType: null,
    hasUnknownMembers: null
  };
  var defs = NODE_FIELDS.EnumNumberBody;
  validate(defs.members, node, "members", members, 1);
  return node;
}

function enumStringBody(members) {
  var node = {
    type: "EnumStringBody",
    members: members,
    explicitType: null,
    hasUnknownMembers: null
  };
  var defs = NODE_FIELDS.EnumStringBody;
  validate(defs.members, node, "members", members, 1);
  return node;
}

function enumSymbolBody(members) {
  var node = {
    type: "EnumSymbolBody",
    members: members,
    hasUnknownMembers: null
  };
  var defs = NODE_FIELDS.EnumSymbolBody;
  validate(defs.members, node, "members", members, 1);
  return node;
}

function enumBooleanMember(id) {
  var node = {
    type: "EnumBooleanMember",
    id: id,
    init: null
  };
  var defs = NODE_FIELDS.EnumBooleanMember;
  validate(defs.id, node, "id", id, 1);
  return node;
}

function enumNumberMember(id, init) {
  var node = {
    type: "EnumNumberMember",
    id: id,
    init: init
  };
  var defs = NODE_FIELDS.EnumNumberMember;
  validate(defs.id, node, "id", id, 1);
  validate(defs.init, node, "init", init, 1);
  return node;
}

function enumStringMember(id, init) {
  var node = {
    type: "EnumStringMember",
    id: id,
    init: init
  };
  var defs = NODE_FIELDS.EnumStringMember;
  validate(defs.id, node, "id", id, 1);
  validate(defs.init, node, "init", init, 1);
  return node;
}

function enumDefaultedMember(id) {
  var node = {
    type: "EnumDefaultedMember",
    id: id
  };
  var defs = NODE_FIELDS.EnumDefaultedMember;
  validate(defs.id, node, "id", id, 1);
  return node;
}

function indexedAccessType(objectType, indexType) {
  var node = {
    type: "IndexedAccessType",
    objectType: objectType,
    indexType: indexType
  };
  var defs = NODE_FIELDS.IndexedAccessType;
  validate(defs.objectType, node, "objectType", objectType, 1);
  validate(defs.indexType, node, "indexType", indexType, 1);
  return node;
}

function optionalIndexedAccessType(objectType, indexType) {
  var node = {
    type: "OptionalIndexedAccessType",
    objectType: objectType,
    indexType: indexType,
    optional: null
  };
  var defs = NODE_FIELDS.OptionalIndexedAccessType;
  validate(defs.objectType, node, "objectType", objectType, 1);
  validate(defs.indexType, node, "indexType", indexType, 1);
  return node;
}

function jsxAttribute(name) {
  var value = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
  var node = {
    type: "JSXAttribute",
    name: name,
    value: value
  };
  var defs = NODE_FIELDS.JSXAttribute;
  validate(defs.name, node, "name", name, 1);
  validate(defs.value, node, "value", value, 1);
  return node;
}

function jsxClosingElement(name) {
  var node = {
    type: "JSXClosingElement",
    name: name
  };
  var defs = NODE_FIELDS.JSXClosingElement;
  validate(defs.name, node, "name", name, 1);
  return node;
}

function jsxElement(openingElement) {
  var closingElement = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
  var children = arguments.length > 2 ? arguments[2] : undefined;
  var selfClosing = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;
  var node = {
    type: "JSXElement",
    openingElement: openingElement,
    closingElement: closingElement,
    children: children,
    selfClosing: selfClosing
  };
  var defs = NODE_FIELDS.JSXElement;
  validate(defs.openingElement, node, "openingElement", openingElement, 1);
  validate(defs.closingElement, node, "closingElement", closingElement, 1);
  validate(defs.children, node, "children", children, 1);
  validate(defs.selfClosing, node, "selfClosing", selfClosing);
  return node;
}

function jsxEmptyExpression() {
  return {
    type: "JSXEmptyExpression"
  };
}

function jsxExpressionContainer(expression) {
  var node = {
    type: "JSXExpressionContainer",
    expression: expression
  };
  var defs = NODE_FIELDS.JSXExpressionContainer;
  validate(defs.expression, node, "expression", expression, 1);
  return node;
}

function jsxSpreadChild(expression) {
  var node = {
    type: "JSXSpreadChild",
    expression: expression
  };
  var defs = NODE_FIELDS.JSXSpreadChild;
  validate(defs.expression, node, "expression", expression, 1);
  return node;
}

function jsxIdentifier(name) {
  var node = {
    type: "JSXIdentifier",
    name: name
  };
  var defs = NODE_FIELDS.JSXIdentifier;
  validate(defs.name, node, "name", name);
  return node;
}

function jsxMemberExpression(object, property) {
  var node = {
    type: "JSXMemberExpression",
    object: object,
    property: property
  };
  var defs = NODE_FIELDS.JSXMemberExpression;
  validate(defs.object, node, "object", object, 1);
  validate(defs.property, node, "property", property, 1);
  return node;
}

function jsxNamespacedName(namespace, name) {
  var node = {
    type: "JSXNamespacedName",
    namespace: namespace,
    name: name
  };
  var defs = NODE_FIELDS.JSXNamespacedName;
  validate(defs.namespace, node, "namespace", namespace, 1);
  validate(defs.name, node, "name", name, 1);
  return node;
}

function jsxOpeningElement(name, attributes) {
  var selfClosing = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
  var node = {
    type: "JSXOpeningElement",
    name: name,
    attributes: attributes,
    selfClosing: selfClosing
  };
  var defs = NODE_FIELDS.JSXOpeningElement;
  validate(defs.name, node, "name", name, 1);
  validate(defs.attributes, node, "attributes", attributes, 1);
  validate(defs.selfClosing, node, "selfClosing", selfClosing);
  return node;
}

function jsxSpreadAttribute(argument) {
  var node = {
    type: "JSXSpreadAttribute",
    argument: argument
  };
  var defs = NODE_FIELDS.JSXSpreadAttribute;
  validate(defs.argument, node, "argument", argument, 1);
  return node;
}

function jsxText(value) {
  var node = {
    type: "JSXText",
    value: value
  };
  var defs = NODE_FIELDS.JSXText;
  validate(defs.value, node, "value", value);
  return node;
}

function jsxFragment(openingFragment, closingFragment, children) {
  var node = {
    type: "JSXFragment",
    openingFragment: openingFragment,
    closingFragment: closingFragment,
    children: children
  };
  var defs = NODE_FIELDS.JSXFragment;
  validate(defs.openingFragment, node, "openingFragment", openingFragment, 1);
  validate(defs.closingFragment, node, "closingFragment", closingFragment, 1);
  validate(defs.children, node, "children", children, 1);
  return node;
}

function jsxOpeningFragment() {
  return {
    type: "JSXOpeningFragment"
  };
}

function jsxClosingFragment() {
  return {
    type: "JSXClosingFragment"
  };
}

function noop() {
  return {
    type: "Noop"
  };
}

function placeholder(expectedNode, name) {
  var node = {
    type: "Placeholder",
    expectedNode: expectedNode,
    name: name
  };
  var defs = NODE_FIELDS.Placeholder;
  validate(defs.expectedNode, node, "expectedNode", expectedNode);
  validate(defs.name, node, "name", name, 1);
  return node;
}

function v8IntrinsicIdentifier(name) {
  var node = {
    type: "V8IntrinsicIdentifier",
    name: name
  };
  var defs = NODE_FIELDS.V8IntrinsicIdentifier;
  validate(defs.name, node, "name", name);
  return node;
}

function argumentPlaceholder() {
  return {
    type: "ArgumentPlaceholder"
  };
}

function bindExpression(object, callee) {
  var node = {
    type: "BindExpression",
    object: object,
    callee: callee
  };
  var defs = NODE_FIELDS.BindExpression;
  validate(defs.object, node, "object", object, 1);
  validate(defs.callee, node, "callee", callee, 1);
  return node;
}

function importAttribute(key, value) {
  var node = {
    type: "ImportAttribute",
    key: key,
    value: value
  };
  var defs = NODE_FIELDS.ImportAttribute;
  validate(defs.key, node, "key", key, 1);
  validate(defs.value, node, "value", value, 1);
  return node;
}

function decorator(expression) {
  var node = {
    type: "Decorator",
    expression: expression
  };
  var defs = NODE_FIELDS.Decorator;
  validate(defs.expression, node, "expression", expression, 1);
  return node;
}

function doExpression(body) {
  var async = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
  var node = {
    type: "DoExpression",
    body: body,
    async: async
  };
  var defs = NODE_FIELDS.DoExpression;
  validate(defs.body, node, "body", body, 1);
  validate(defs.async, node, "async", async);
  return node;
}

function exportDefaultSpecifier(exported) {
  var node = {
    type: "ExportDefaultSpecifier",
    exported: exported
  };
  var defs = NODE_FIELDS.ExportDefaultSpecifier;
  validate(defs.exported, node, "exported", exported, 1);
  return node;
}

function recordExpression(properties) {
  var node = {
    type: "RecordExpression",
    properties: properties
  };
  var defs = NODE_FIELDS.RecordExpression;
  validate(defs.properties, node, "properties", properties, 1);
  return node;
}

function tupleExpression() {
  var elements = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];
  var node = {
    type: "TupleExpression",
    elements: elements
  };
  var defs = NODE_FIELDS.TupleExpression;
  validate(defs.elements, node, "elements", elements, 1);
  return node;
}

function decimalLiteral(value) {
  var node = {
    type: "DecimalLiteral",
    value: value
  };
  var defs = NODE_FIELDS.DecimalLiteral;
  validate(defs.value, node, "value", value);
  return node;
}

function moduleExpression(body) {
  var node = {
    type: "ModuleExpression",
    body: body
  };
  var defs = NODE_FIELDS.ModuleExpression;
  validate(defs.body, node, "body", body, 1);
  return node;
}

function topicReference() {
  return {
    type: "TopicReference"
  };
}

function pipelineTopicExpression(expression) {
  var node = {
    type: "PipelineTopicExpression",
    expression: expression
  };
  var defs = NODE_FIELDS.PipelineTopicExpression;
  validate(defs.expression, node, "expression", expression, 1);
  return node;
}

function pipelineBareFunction(callee) {
  var node = {
    type: "PipelineBareFunction",
    callee: callee
  };
  var defs = NODE_FIELDS.PipelineBareFunction;
  validate(defs.callee, node, "callee", callee, 1);
  return node;
}

function pipelinePrimaryTopicReference() {
  return {
    type: "PipelinePrimaryTopicReference"
  };
}

function tsParameterProperty(parameter) {
  var node = {
    type: "TSParameterProperty",
    parameter: parameter
  };
  var defs = NODE_FIELDS.TSParameterProperty;
  validate(defs.parameter, node, "parameter", parameter, 1);
  return node;
}

function tsDeclareFunction() {
  var id = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;
  var typeParameters = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
  var params = arguments.length > 2 ? arguments[2] : undefined;
  var returnType = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;
  var node = {
    type: "TSDeclareFunction",
    id: id,
    typeParameters: typeParameters,
    params: params,
    returnType: returnType
  };
  var defs = NODE_FIELDS.TSDeclareFunction;
  validate(defs.id, node, "id", id, 1);
  validate(defs.typeParameters, node, "typeParameters", typeParameters, 1);
  validate(defs.params, node, "params", params, 1);
  validate(defs.returnType, node, "returnType", returnType, 1);
  return node;
}

function tsDeclareMethod() {
  var decorators = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;
  var key = arguments.length > 1 ? arguments[1] : undefined;
  var typeParameters = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;
  var params = arguments.length > 3 ? arguments[3] : undefined;
  var returnType = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : null;
  var node = {
    type: "TSDeclareMethod",
    decorators: decorators,
    key: key,
    typeParameters: typeParameters,
    params: params,
    returnType: returnType
  };
  var defs = NODE_FIELDS.TSDeclareMethod;
  validate(defs.decorators, node, "decorators", decorators, 1);
  validate(defs.key, node, "key", key, 1);
  validate(defs.typeParameters, node, "typeParameters", typeParameters, 1);
  validate(defs.params, node, "params", params, 1);
  validate(defs.returnType, node, "returnType", returnType, 1);
  return node;
}

function tsQualifiedName(left, right) {
  var node = {
    type: "TSQualifiedName",
    left: left,
    right: right
  };
  var defs = NODE_FIELDS.TSQualifiedName;
  validate(defs.left, node, "left", left, 1);
  validate(defs.right, node, "right", right, 1);
  return node;
}

function tsCallSignatureDeclaration() {
  var typeParameters = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;
  var parameters = arguments.length > 1 ? arguments[1] : undefined;
  var typeAnnotation = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;
  var node = {
    type: "TSCallSignatureDeclaration",
    typeParameters: typeParameters,
    parameters: parameters,
    typeAnnotation: typeAnnotation
  };
  var defs = NODE_FIELDS.TSCallSignatureDeclaration;
  validate(defs.typeParameters, node, "typeParameters", typeParameters, 1);
  validate(defs.parameters, node, "parameters", parameters, 1);
  validate(defs.typeAnnotation, node, "typeAnnotation", typeAnnotation, 1);
  return node;
}

function tsConstructSignatureDeclaration() {
  var typeParameters = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;
  var parameters = arguments.length > 1 ? arguments[1] : undefined;
  var typeAnnotation = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;
  var node = {
    type: "TSConstructSignatureDeclaration",
    typeParameters: typeParameters,
    parameters: parameters,
    typeAnnotation: typeAnnotation
  };
  var defs = NODE_FIELDS.TSConstructSignatureDeclaration;
  validate(defs.typeParameters, node, "typeParameters", typeParameters, 1);
  validate(defs.parameters, node, "parameters", parameters, 1);
  validate(defs.typeAnnotation, node, "typeAnnotation", typeAnnotation, 1);
  return node;
}

function tsPropertySignature(key) {
  var typeAnnotation = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
  var node = {
    type: "TSPropertySignature",
    key: key,
    typeAnnotation: typeAnnotation,
    kind: null
  };
  var defs = NODE_FIELDS.TSPropertySignature;
  validate(defs.key, node, "key", key, 1);
  validate(defs.typeAnnotation, node, "typeAnnotation", typeAnnotation, 1);
  return node;
}

function tsMethodSignature(key) {
  var typeParameters = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
  var parameters = arguments.length > 2 ? arguments[2] : undefined;
  var typeAnnotation = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;
  var node = {
    type: "TSMethodSignature",
    key: key,
    typeParameters: typeParameters,
    parameters: parameters,
    typeAnnotation: typeAnnotation,
    kind: null
  };
  var defs = NODE_FIELDS.TSMethodSignature;
  validate(defs.key, node, "key", key, 1);
  validate(defs.typeParameters, node, "typeParameters", typeParameters, 1);
  validate(defs.parameters, node, "parameters", parameters, 1);
  validate(defs.typeAnnotation, node, "typeAnnotation", typeAnnotation, 1);
  return node;
}

function tsIndexSignature(parameters) {
  var typeAnnotation = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
  var node = {
    type: "TSIndexSignature",
    parameters: parameters,
    typeAnnotation: typeAnnotation
  };
  var defs = NODE_FIELDS.TSIndexSignature;
  validate(defs.parameters, node, "parameters", parameters, 1);
  validate(defs.typeAnnotation, node, "typeAnnotation", typeAnnotation, 1);
  return node;
}

function tsAnyKeyword() {
  return {
    type: "TSAnyKeyword"
  };
}

function tsBooleanKeyword() {
  return {
    type: "TSBooleanKeyword"
  };
}

function tsBigIntKeyword() {
  return {
    type: "TSBigIntKeyword"
  };
}

function tsIntrinsicKeyword() {
  return {
    type: "TSIntrinsicKeyword"
  };
}

function tsNeverKeyword() {
  return {
    type: "TSNeverKeyword"
  };
}

function tsNullKeyword() {
  return {
    type: "TSNullKeyword"
  };
}

function tsNumberKeyword() {
  return {
    type: "TSNumberKeyword"
  };
}

function tsObjectKeyword() {
  return {
    type: "TSObjectKeyword"
  };
}

function tsStringKeyword() {
  return {
    type: "TSStringKeyword"
  };
}

function tsSymbolKeyword() {
  return {
    type: "TSSymbolKeyword"
  };
}

function tsUndefinedKeyword() {
  return {
    type: "TSUndefinedKeyword"
  };
}

function tsUnknownKeyword() {
  return {
    type: "TSUnknownKeyword"
  };
}

function tsVoidKeyword() {
  return {
    type: "TSVoidKeyword"
  };
}

function tsThisType() {
  return {
    type: "TSThisType"
  };
}

function tsFunctionType() {
  var typeParameters = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;
  var parameters = arguments.length > 1 ? arguments[1] : undefined;
  var typeAnnotation = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;
  var node = {
    type: "TSFunctionType",
    typeParameters: typeParameters,
    parameters: parameters,
    typeAnnotation: typeAnnotation
  };
  var defs = NODE_FIELDS.TSFunctionType;
  validate(defs.typeParameters, node, "typeParameters", typeParameters, 1);
  validate(defs.parameters, node, "parameters", parameters, 1);
  validate(defs.typeAnnotation, node, "typeAnnotation", typeAnnotation, 1);
  return node;
}

function tsConstructorType() {
  var typeParameters = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;
  var parameters = arguments.length > 1 ? arguments[1] : undefined;
  var typeAnnotation = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;
  var node = {
    type: "TSConstructorType",
    typeParameters: typeParameters,
    parameters: parameters,
    typeAnnotation: typeAnnotation
  };
  var defs = NODE_FIELDS.TSConstructorType;
  validate(defs.typeParameters, node, "typeParameters", typeParameters, 1);
  validate(defs.parameters, node, "parameters", parameters, 1);
  validate(defs.typeAnnotation, node, "typeAnnotation", typeAnnotation, 1);
  return node;
}

function tsTypeReference(typeName) {
  var typeParameters = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
  var node = {
    type: "TSTypeReference",
    typeName: typeName,
    typeParameters: typeParameters
  };
  var defs = NODE_FIELDS.TSTypeReference;
  validate(defs.typeName, node, "typeName", typeName, 1);
  validate(defs.typeParameters, node, "typeParameters", typeParameters, 1);
  return node;
}

function tsTypePredicate(parameterName) {
  var typeAnnotation = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
  var asserts = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;
  var node = {
    type: "TSTypePredicate",
    parameterName: parameterName,
    typeAnnotation: typeAnnotation,
    asserts: asserts
  };
  var defs = NODE_FIELDS.TSTypePredicate;
  validate(defs.parameterName, node, "parameterName", parameterName, 1);
  validate(defs.typeAnnotation, node, "typeAnnotation", typeAnnotation, 1);
  validate(defs.asserts, node, "asserts", asserts);
  return node;
}

function tsTypeQuery(exprName) {
  var typeParameters = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
  var node = {
    type: "TSTypeQuery",
    exprName: exprName,
    typeParameters: typeParameters
  };
  var defs = NODE_FIELDS.TSTypeQuery;
  validate(defs.exprName, node, "exprName", exprName, 1);
  validate(defs.typeParameters, node, "typeParameters", typeParameters, 1);
  return node;
}

function tsTypeLiteral(members) {
  var node = {
    type: "TSTypeLiteral",
    members: members
  };
  var defs = NODE_FIELDS.TSTypeLiteral;
  validate(defs.members, node, "members", members, 1);
  return node;
}

function tsArrayType(elementType) {
  var node = {
    type: "TSArrayType",
    elementType: elementType
  };
  var defs = NODE_FIELDS.TSArrayType;
  validate(defs.elementType, node, "elementType", elementType, 1);
  return node;
}

function tsTupleType(elementTypes) {
  var node = {
    type: "TSTupleType",
    elementTypes: elementTypes
  };
  var defs = NODE_FIELDS.TSTupleType;
  validate(defs.elementTypes, node, "elementTypes", elementTypes, 1);
  return node;
}

function tsOptionalType(typeAnnotation) {
  var node = {
    type: "TSOptionalType",
    typeAnnotation: typeAnnotation
  };
  var defs = NODE_FIELDS.TSOptionalType;
  validate(defs.typeAnnotation, node, "typeAnnotation", typeAnnotation, 1);
  return node;
}

function tsRestType(typeAnnotation) {
  var node = {
    type: "TSRestType",
    typeAnnotation: typeAnnotation
  };
  var defs = NODE_FIELDS.TSRestType;
  validate(defs.typeAnnotation, node, "typeAnnotation", typeAnnotation, 1);
  return node;
}

function tsNamedTupleMember(label, elementType) {
  var optional = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
  var node = {
    type: "TSNamedTupleMember",
    label: label,
    elementType: elementType,
    optional: optional
  };
  var defs = NODE_FIELDS.TSNamedTupleMember;
  validate(defs.label, node, "label", label, 1);
  validate(defs.elementType, node, "elementType", elementType, 1);
  validate(defs.optional, node, "optional", optional);
  return node;
}

function tsUnionType(types) {
  var node = {
    type: "TSUnionType",
    types: types
  };
  var defs = NODE_FIELDS.TSUnionType;
  validate(defs.types, node, "types", types, 1);
  return node;
}

function tsIntersectionType(types) {
  var node = {
    type: "TSIntersectionType",
    types: types
  };
  var defs = NODE_FIELDS.TSIntersectionType;
  validate(defs.types, node, "types", types, 1);
  return node;
}

function tsConditionalType(checkType, extendsType, trueType, falseType) {
  var node = {
    type: "TSConditionalType",
    checkType: checkType,
    extendsType: extendsType,
    trueType: trueType,
    falseType: falseType
  };
  var defs = NODE_FIELDS.TSConditionalType;
  validate(defs.checkType, node, "checkType", checkType, 1);
  validate(defs.extendsType, node, "extendsType", extendsType, 1);
  validate(defs.trueType, node, "trueType", trueType, 1);
  validate(defs.falseType, node, "falseType", falseType, 1);
  return node;
}

function tsInferType(typeParameter) {
  var node = {
    type: "TSInferType",
    typeParameter: typeParameter
  };
  var defs = NODE_FIELDS.TSInferType;
  validate(defs.typeParameter, node, "typeParameter", typeParameter, 1);
  return node;
}

function tsParenthesizedType(typeAnnotation) {
  var node = {
    type: "TSParenthesizedType",
    typeAnnotation: typeAnnotation
  };
  var defs = NODE_FIELDS.TSParenthesizedType;
  validate(defs.typeAnnotation, node, "typeAnnotation", typeAnnotation, 1);
  return node;
}

function tsTypeOperator(typeAnnotation) {
  var node = {
    type: "TSTypeOperator",
    typeAnnotation: typeAnnotation,
    operator: null
  };
  var defs = NODE_FIELDS.TSTypeOperator;
  validate(defs.typeAnnotation, node, "typeAnnotation", typeAnnotation, 1);
  return node;
}

function tsIndexedAccessType(objectType, indexType) {
  var node = {
    type: "TSIndexedAccessType",
    objectType: objectType,
    indexType: indexType
  };
  var defs = NODE_FIELDS.TSIndexedAccessType;
  validate(defs.objectType, node, "objectType", objectType, 1);
  validate(defs.indexType, node, "indexType", indexType, 1);
  return node;
}

function tsMappedType(typeParameter) {
  var typeAnnotation = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
  var nameType = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;
  var node = {
    type: "TSMappedType",
    typeParameter: typeParameter,
    typeAnnotation: typeAnnotation,
    nameType: nameType
  };
  var defs = NODE_FIELDS.TSMappedType;
  validate(defs.typeParameter, node, "typeParameter", typeParameter, 1);
  validate(defs.typeAnnotation, node, "typeAnnotation", typeAnnotation, 1);
  validate(defs.nameType, node, "nameType", nameType, 1);
  return node;
}

function tsLiteralType(literal) {
  var node = {
    type: "TSLiteralType",
    literal: literal
  };
  var defs = NODE_FIELDS.TSLiteralType;
  validate(defs.literal, node, "literal", literal, 1);
  return node;
}

function tsExpressionWithTypeArguments(expression) {
  var typeParameters = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
  var node = {
    type: "TSExpressionWithTypeArguments",
    expression: expression,
    typeParameters: typeParameters
  };
  var defs = NODE_FIELDS.TSExpressionWithTypeArguments;
  validate(defs.expression, node, "expression", expression, 1);
  validate(defs.typeParameters, node, "typeParameters", typeParameters, 1);
  return node;
}

function tsInterfaceDeclaration(id) {
  var typeParameters = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;

  var _extends = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;

  var body = arguments.length > 3 ? arguments[3] : undefined;
  var node = {
    type: "TSInterfaceDeclaration",
    id: id,
    typeParameters: typeParameters,
    "extends": _extends,
    body: body
  };
  var defs = NODE_FIELDS.TSInterfaceDeclaration;
  validate(defs.id, node, "id", id, 1);
  validate(defs.typeParameters, node, "typeParameters", typeParameters, 1);
  validate(defs["extends"], node, "extends", _extends, 1);
  validate(defs.body, node, "body", body, 1);
  return node;
}

function tsInterfaceBody(body) {
  var node = {
    type: "TSInterfaceBody",
    body: body
  };
  var defs = NODE_FIELDS.TSInterfaceBody;
  validate(defs.body, node, "body", body, 1);
  return node;
}

function tsTypeAliasDeclaration(id) {
  var typeParameters = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
  var typeAnnotation = arguments.length > 2 ? arguments[2] : undefined;
  var node = {
    type: "TSTypeAliasDeclaration",
    id: id,
    typeParameters: typeParameters,
    typeAnnotation: typeAnnotation
  };
  var defs = NODE_FIELDS.TSTypeAliasDeclaration;
  validate(defs.id, node, "id", id, 1);
  validate(defs.typeParameters, node, "typeParameters", typeParameters, 1);
  validate(defs.typeAnnotation, node, "typeAnnotation", typeAnnotation, 1);
  return node;
}

function tsInstantiationExpression(expression) {
  var typeParameters = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
  var node = {
    type: "TSInstantiationExpression",
    expression: expression,
    typeParameters: typeParameters
  };
  var defs = NODE_FIELDS.TSInstantiationExpression;
  validate(defs.expression, node, "expression", expression, 1);
  validate(defs.typeParameters, node, "typeParameters", typeParameters, 1);
  return node;
}

function tsAsExpression(expression, typeAnnotation) {
  var node = {
    type: "TSAsExpression",
    expression: expression,
    typeAnnotation: typeAnnotation
  };
  var defs = NODE_FIELDS.TSAsExpression;
  validate(defs.expression, node, "expression", expression, 1);
  validate(defs.typeAnnotation, node, "typeAnnotation", typeAnnotation, 1);
  return node;
}

function tsSatisfiesExpression(expression, typeAnnotation) {
  var node = {
    type: "TSSatisfiesExpression",
    expression: expression,
    typeAnnotation: typeAnnotation
  };
  var defs = NODE_FIELDS.TSSatisfiesExpression;
  validate(defs.expression, node, "expression", expression, 1);
  validate(defs.typeAnnotation, node, "typeAnnotation", typeAnnotation, 1);
  return node;
}

function tsTypeAssertion(typeAnnotation, expression) {
  var node = {
    type: "TSTypeAssertion",
    typeAnnotation: typeAnnotation,
    expression: expression
  };
  var defs = NODE_FIELDS.TSTypeAssertion;
  validate(defs.typeAnnotation, node, "typeAnnotation", typeAnnotation, 1);
  validate(defs.expression, node, "expression", expression, 1);
  return node;
}

function tsEnumDeclaration(id, members) {
  var node = {
    type: "TSEnumDeclaration",
    id: id,
    members: members
  };
  var defs = NODE_FIELDS.TSEnumDeclaration;
  validate(defs.id, node, "id", id, 1);
  validate(defs.members, node, "members", members, 1);
  return node;
}

function tsEnumMember(id) {
  var initializer = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
  var node = {
    type: "TSEnumMember",
    id: id,
    initializer: initializer
  };
  var defs = NODE_FIELDS.TSEnumMember;
  validate(defs.id, node, "id", id, 1);
  validate(defs.initializer, node, "initializer", initializer, 1);
  return node;
}

function tsModuleDeclaration(id, body) {
  var node = {
    type: "TSModuleDeclaration",
    id: id,
    body: body
  };
  var defs = NODE_FIELDS.TSModuleDeclaration;
  validate(defs.id, node, "id", id, 1);
  validate(defs.body, node, "body", body, 1);
  return node;
}

function tsModuleBlock(body) {
  var node = {
    type: "TSModuleBlock",
    body: body
  };
  var defs = NODE_FIELDS.TSModuleBlock;
  validate(defs.body, node, "body", body, 1);
  return node;
}

function tsImportType(argument) {
  var qualifier = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
  var typeParameters = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;
  var node = {
    type: "TSImportType",
    argument: argument,
    qualifier: qualifier,
    typeParameters: typeParameters
  };
  var defs = NODE_FIELDS.TSImportType;
  validate(defs.argument, node, "argument", argument, 1);
  validate(defs.qualifier, node, "qualifier", qualifier, 1);
  validate(defs.typeParameters, node, "typeParameters", typeParameters, 1);
  return node;
}

function tsImportEqualsDeclaration(id, moduleReference) {
  var node = {
    type: "TSImportEqualsDeclaration",
    id: id,
    moduleReference: moduleReference,
    isExport: null
  };
  var defs = NODE_FIELDS.TSImportEqualsDeclaration;
  validate(defs.id, node, "id", id, 1);
  validate(defs.moduleReference, node, "moduleReference", moduleReference, 1);
  return node;
}

function tsExternalModuleReference(expression) {
  var node = {
    type: "TSExternalModuleReference",
    expression: expression
  };
  var defs = NODE_FIELDS.TSExternalModuleReference;
  validate(defs.expression, node, "expression", expression, 1);
  return node;
}

function tsNonNullExpression(expression) {
  var node = {
    type: "TSNonNullExpression",
    expression: expression
  };
  var defs = NODE_FIELDS.TSNonNullExpression;
  validate(defs.expression, node, "expression", expression, 1);
  return node;
}

function tsExportAssignment(expression) {
  var node = {
    type: "TSExportAssignment",
    expression: expression
  };
  var defs = NODE_FIELDS.TSExportAssignment;
  validate(defs.expression, node, "expression", expression, 1);
  return node;
}

function tsNamespaceExportDeclaration(id) {
  var node = {
    type: "TSNamespaceExportDeclaration",
    id: id
  };
  var defs = NODE_FIELDS.TSNamespaceExportDeclaration;
  validate(defs.id, node, "id", id, 1);
  return node;
}

function tsTypeAnnotation(typeAnnotation) {
  var node = {
    type: "TSTypeAnnotation",
    typeAnnotation: typeAnnotation
  };
  var defs = NODE_FIELDS.TSTypeAnnotation;
  validate(defs.typeAnnotation, node, "typeAnnotation", typeAnnotation, 1);
  return node;
}

function tsTypeParameterInstantiation(params) {
  var node = {
    type: "TSTypeParameterInstantiation",
    params: params
  };
  var defs = NODE_FIELDS.TSTypeParameterInstantiation;
  validate(defs.params, node, "params", params, 1);
  return node;
}

function tsTypeParameterDeclaration(params) {
  var node = {
    type: "TSTypeParameterDeclaration",
    params: params
  };
  var defs = NODE_FIELDS.TSTypeParameterDeclaration;
  validate(defs.params, node, "params", params, 1);
  return node;
}

function tsTypeParameter() {
  var constraint = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;

  var _default = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;

  var name = arguments.length > 2 ? arguments[2] : undefined;
  var node = {
    type: "TSTypeParameter",
    constraint: constraint,
    "default": _default,
    name: name
  };
  var defs = NODE_FIELDS.TSTypeParameter;
  validate(defs.constraint, node, "constraint", constraint, 1);
  validate(defs["default"], node, "default", _default, 1);
  validate(defs.name, node, "name", name);
  return node;
}

function NumberLiteral(value) {
  (0, _deprecationWarning["default"])("NumberLiteral", "NumericLiteral", "The node type ");
  return numericLiteral(value);
}

function RegexLiteral(pattern) {
  var flags = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : "";
  (0, _deprecationWarning["default"])("RegexLiteral", "RegExpLiteral", "The node type ");
  return regExpLiteral(pattern, flags);
}

function RestProperty(argument) {
  (0, _deprecationWarning["default"])("RestProperty", "RestElement", "The node type ");
  return restElement(argument);
}

function SpreadProperty(argument) {
  (0, _deprecationWarning["default"])("SpreadProperty", "SpreadElement", "The node type ");
  return spreadElement(argument);
}