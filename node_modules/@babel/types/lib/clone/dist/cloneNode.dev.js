"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = cloneNode;

var _index = require("../definitions/index.js");

var _index2 = require("../validators/generated/index.js");

var _hasOwn = {
  hasOwn: Function.call.bind(Object.prototype.hasOwnProperty)
},
    hasOwn = _hasOwn.hasOwn;

function cloneIfNode(obj, deep, withoutLoc, commentsCache) {
  if (obj && typeof obj.type === "string") {
    return cloneNodeInternal(obj, deep, withoutLoc, commentsCache);
  }

  return obj;
}

function cloneIfNodeOrArray(obj, deep, withoutLoc, commentsCache) {
  if (Array.isArray(obj)) {
    return obj.map(function (node) {
      return cloneIfNode(node, deep, withoutLoc, commentsCache);
    });
  }

  return cloneIfNode(obj, deep, withoutLoc, commentsCache);
}

function cloneNode(node) {
  var deep = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;
  var withoutLoc = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
  return cloneNodeInternal(node, deep, withoutLoc, new Map());
}

function cloneNodeInternal(node) {
  var deep = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;
  var withoutLoc = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
  var commentsCache = arguments.length > 3 ? arguments[3] : undefined;
  if (!node) return node;
  var type = node.type;
  var newNode = {
    type: node.type
  };

  if ((0, _index2.isIdentifier)(node)) {
    newNode.name = node.name;

    if (hasOwn(node, "optional") && typeof node.optional === "boolean") {
      newNode.optional = node.optional;
    }

    if (hasOwn(node, "typeAnnotation")) {
      newNode.typeAnnotation = deep ? cloneIfNodeOrArray(node.typeAnnotation, true, withoutLoc, commentsCache) : node.typeAnnotation;
    }

    if (hasOwn(node, "decorators")) {
      newNode.decorators = deep ? cloneIfNodeOrArray(node.decorators, true, withoutLoc, commentsCache) : node.decorators;
    }
  } else if (!hasOwn(_index.NODE_FIELDS, type)) {
    throw new Error("Unknown node type: \"".concat(type, "\""));
  } else {
    for (var _i = 0, _Object$keys = Object.keys(_index.NODE_FIELDS[type]); _i < _Object$keys.length; _i++) {
      var field = _Object$keys[_i];

      if (hasOwn(node, field)) {
        if (deep) {
          newNode[field] = (0, _index2.isFile)(node) && field === "comments" ? maybeCloneComments(node.comments, deep, withoutLoc, commentsCache) : cloneIfNodeOrArray(node[field], true, withoutLoc, commentsCache);
        } else {
          newNode[field] = node[field];
        }
      }
    }
  }

  if (hasOwn(node, "loc")) {
    if (withoutLoc) {
      newNode.loc = null;
    } else {
      newNode.loc = node.loc;
    }
  }

  if (hasOwn(node, "leadingComments")) {
    newNode.leadingComments = maybeCloneComments(node.leadingComments, deep, withoutLoc, commentsCache);
  }

  if (hasOwn(node, "innerComments")) {
    newNode.innerComments = maybeCloneComments(node.innerComments, deep, withoutLoc, commentsCache);
  }

  if (hasOwn(node, "trailingComments")) {
    newNode.trailingComments = maybeCloneComments(node.trailingComments, deep, withoutLoc, commentsCache);
  }

  if (hasOwn(node, "extra")) {
    newNode.extra = Object.assign({}, node.extra);
  }

  return newNode;
}

function maybeCloneComments(comments, deep, withoutLoc, commentsCache) {
  if (!comments || !deep) {
    return comments;
  }

  return comments.map(function (comment) {
    var cache = commentsCache.get(comment);
    if (cache) return cache;
    var type = comment.type,
        value = comment.value,
        loc = comment.loc;
    var ret = {
      type: type,
      value: value,
      loc: loc
    };

    if (withoutLoc) {
      ret.loc = null;
    }

    commentsCache.set(comment, ret);
    return ret;
  });
}